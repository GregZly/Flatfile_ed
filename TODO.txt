-[ZROBIONE]odczyt pliku płaskiego do pamięci i render na stronę
	-[ZROBIONE]odczyt i wydruk w konsoli
	-[ZROBIONE]odczyt i render na stronie całymi liniami
	-[ZROBIONE]Render na stronie pojedyńczymi komórkami
-[ZROBIONE]dopisywanie czegokolwiek do pliku i zapis
	-[ZROBIONE]wersja konsolowa - jedna linia
	-[ZROBIONE]wersja przeglądarkowa - jedna linia
		-[ZROBIONE]formularz: input text i submit button
		-[ZROBIONE]rozwiązać problem dodatkowego  wiersza w pliku
			-do polecenia open trzeba dodać dodatkowy parameter newline=''
	-[ZROBIONE]wersja przeglądarkowa - 3 komórki na sztywno
-[ZROBIONE]modyfikacja istniejącego wiersza pliku
	-[ZROBIONE]konsolowe wyszukanie wiersza i jego modyfikacja
		-[ZROBIONE]zmienić sposób postępowania przy zapisie
			-[ZROBIONE]wczytać plik w trybie w 
			-[ZROBIONE]zapis całej zawartości zbioru danych
		-[ZROBIONE]modyfikacja danej w tablicy i zapis jak wyżej
	-[ZROBIONE]update wybranego wiersza w przeglądarce
		-[ZROBIONE]lista wierszy z dodatkowym przyciskiem do modyfikacji
			-[ZROBIONE]lista w pełni proceduralna (kolumny i wiersze dynamicznie)
			-[ZROBIONE]Button który odpali formularz z modyfikacją wiersza
			-[ZROBIONE]formularz do modyfikacji (ma mieć dane wybranego wiersza)
		-[ZROBIONE]oddzielna stronka z modyfikacją wiersza
		-[ZROBIONE]skrypt który zmodyfikuje plik i powróci do strony listą danych
-[ZROBIONE]dodanie wiersza i posortowaniem jako opcja
	-[ZROBIONE]kopia formularza append_row
		-[ZROBIONE]check box do posortowania danych
	-[ZROBIONE]obsługa sortowania i zapis w pliku który wykonuje app
-[ZROBIONE]usunięcie wiersza
	-[ZROBIONE]button na liście do usuwania
	-[ZROBIONE]usunięcie wpisu
	-[ZROBIONE]pokazanie odświeżonej listy
-[ZROBIONE]kopia wiersza i dodanie lnijki niżej
	-to trochę bez sensu ale możnaby rozszerzyć mod_row_html
	-[ZROBIONE]dodać buttona do dodatkowego save-u jako nowy wiersz
	-[ZROBIONE]dołożyć obsługę dodania nowego wiersza w modifiable_list.py
-[ZROBIONE]zapis do zmiennej ilości kolumn (obecnie to 3 kolumny na sztywno)
	-[ZROBIONE]zrozumieć jak działa typ danych Dict któym Flask przerzuca dane z formularzy
	-[ZROBIONE]odwoływać się do do zbioru tak żebym zebrał generycznie potrzebne dane
	-[ZROBIONE]przerobić tak modifiable_list.py żeby nie było odwołania się do kolumn "na sztywno"
	 przy zapisie,updacie
-[ZROBIONE]bakup pliku
	-[ZROBIONE]kopia używanego pliku do lokalnego folderu aplikacji /backup
		-[ZROBIONE]szablon nazwy pliku: DATA_CZAS_NAZWA.EXT.BAK
		-[ZROBIONE].gitignore - folder /backup ma być w repo, ale zawartość nie
	-[ZROBIONE]przycisk zrobienia backupu 
		-[ZROBIONE]dodać do modifiable_list.html
-[ZROBIONE]przywrócenie z bakupu
	-[ZROBIONE]oddzielna strona z listą backupów
		-[ZROBIONE]posortowane od najmłodszego
	-[ZROBIONE]przycisk na pierwszej stronie odsyłający do listy backupów
	-[ZROBIONE]podgląd backupu
	-[ZROBIONE]przycisk na podglądzie do przywrócenia
	-[ZROBIONE]przywrócenie i powrót na pierwszą stronę po przywróceniu
-[ZROBIONE]przeniesienie kopii kodu do oddzielnych funkcji(czyli trochę inżnierii)
	-[ZROBIONE]Rozwiązać problem podłączania własnych modułów do aplikacji Flask
		-na chwilę obecną rozwiązaniem jest "krzywy" import biblioteki	
		 poprzez odwołanie się do tego samego katalogu mimo że plik do którego jest
		 wykonywany import już tam jest
	-[ZROBIONE]otwieranie pliku csv
	-[ZROBIONE]zapis do pliku csv

-[ZROBIONE]zebranie wszystkich klocków do jednej aplikacji (przy pracy na lokalnym pliku)
	-to musi być zrobione jako szablon dużej aplikacji flaska	
	-[ZROBIONE]zrobić oddzielnego brancha na tę zmianę
	-[ZROBIONE]zreorganizować uruchamianie aplikacji - prawidłowe użycie run i modułów
			-[ZROBIONE]Rozwiązać dziwny problem z procedurą backupu - wygląda to tak jakby routing 
				  na tę kontrektną procedurę przestawał działać po pierwszym kliknięciu i od razu szedł
				  do routingu głównego.Nawet konsola pythona nie pokazuje przejścia na inny routuing
				-[ZROBIONE]Sprawdzić inną przeglądarke
						-[ZROBIONE]Edge - chodzi jak powinno
						-[ZROBIONE]Internet Explorer - chodzi jak powinno
						-[ZROBIONE]Chrome na Incognito - chodzi jak powinno
				-[ZROBIONE]zamienić zwykły button na pełen formularz
					-i teraz działa, widać więc że konstrukcji onclick href location trzeba raczej unikać
	-[ZROBIONE]Usunąć zbędne pliki 
	-[ZROBIONE]zrobić sensowny overwrite brancha master, branchem large_app
		-chyba wszystko zrobiłem ok. widze te pliki których chcę używać i mam brancha master

-[ZROBIONE]testy do powyższych funkcjonalności
	-[ZROBIONE]poczytać jak robić testy jednostkowe dla flaska
		-[ZROBIONE]pytest 
			-na potrzeby tego projektu nie ma sensu się w to zagłębiać
			-najpierw zrobię jak mi się wydaje że jest dobrze a douczać się będę na bieżąco
			-następny pet project będzie zakładać użycie tdd od początku
		-[ZROBIONE]materiały flaska 
			-najpierw jedna pytest trzeba przerobić bo zupełnie nic o tym nie wiem
			-dużo opisanych sposobów na testowanie
	-[ZROBIONE]Rozwiązać problem użycia przez VS Code całego pythona zamiast venv
		-rozwiązanie: Zamknąć folder nadrzędny w VS Code i otworzyć folder w wybranym projekcie.
				      Wtedy, o dziwo venv jakoś się załapuje do listy
	-[ZROBIONE]otestować wszystkie pliki
		-[ZROBIONE]csv_interface
			-[ZROBIONE]funkcja get_csv
				-[ZROBIONE]poprawny odczyt danych
				-[ZROBIONE]zwrócenie błędu przy błędnym odczycie(tu można dodać try-catch)
					-dodano try except żeby zwracać komunikat błędu
					-w sumie to wyszło trochę tdd bo najpierw zrobiłem wyszukiwanie błędu a potem dodałem 
					 funkcję zwracania tego błędu przy błędnym zachowaniu :-)
			-[ZROBIONE]funkcja save_csv
				-[ZROBIONE]poprawny zapis
				-[ZROBIONE]błędny zapis - brak uprawnień
					-tutaj uświadmiłem sobie że mógłbym lock-ować plik 
					 gdyby dwóch użytkowników chciało go edytować jednocześnie
		-[ZROBIONE]flatfile_operations
			-Testy które mogę przeprowadzić
				-zwracany kod protokołu (200, 301 i kody błędów)
				-elementy html które są na stronie
			-[ZROBIONE]Przygotować oddzielny runner do testowania aplikacji
				-chyba się udało, bo przykład ze strony flaska działa
			-[ZROBIONE]routing / i /index
				-[ZROBIONE]czy jest kod 200 przy wejściu
				-[ZROBIONE]Czy pojawił się element 'Modifiable CSV' na stronie
				-[ZROBIONE]czy pokazał się odczyt z pliku csv
					-[ZROBIONE]tu by trzeba ten plik odczytać procedurą CSV i sprawdzić 
					 czy pierwsza i ostatnia linijka się pojawiła
					 	-[ZROBIONE]najlepiej to byłoby przerobić aplikację by plik do flatfile_operations
						 był wczytywany z konfigu. Wtedy konfig testowy wszystko by podmieniał
				-[ZROBIONE]błędy
					-[NIE DA SIĘ]próba odczytu pliku który ma zablokowane prawa do odczytu
						-nie da się na windows zablokować sobie samemu pliku
			-[ZROBIONE]add row
				-[ZROBIONE]metoda GET
					-[ZROBIONE]czy jest kod 200
					-[ZROBIONE]czy pojawiają się elementy formularza
				-[ZROBIONE]metoda POST
					-[ZROBIONE]udane bez sortowania
						-[ZROBIONE]czy nowy wiersz pojawił się w pliku
							-[ZROBIONE]Naprawić błąd zapisu pliku (zapisuje dane w dict())
						-[ZROBIONE]czy jest kod 200 
					-[ZROBIONE]udane z sortowaniem
						-[ZROBIONE]czy nowy wiersz jest
						-[ZROBIONE]czy wprowadzony wiersz pojawił się w spodziewanym miejscu
						-[ZROBIONE]czy jest kod 200 przy przekierowaniu
					-[ZROBIONE]nieudane 
						-[ZROBIONE]czy jest błąd blokady pliku
						-[ZROBIONE]czy wprowadzany wiersz nie istnije
						-[ZROBIONE]czy jest kod 200 przy przekierowaniu

			-[ZROBIONE]mod row
				-[ZROBIONE]czy formularz do modyfikacji pokazał się
				-[ZROBIONE]czy dane z wybranego wiersza zostały przekazane do formularza
				-[ZROBIONE]czy jest kod 200 przy przeglądarce
			-[ZROBIONE]save mod
				-[ZROBIONE]modify
					-[ZROBIONE]sukces modyfikacji wybranego wiersza
						-[ZROBIONE]wprowadzenie postem wiersza do pliku CSV
						-[ZROBIONE]kod 200 z przeglądarki
					-[ZROBIONE]porażka modyfikacji wybranego wiersza (nieistniejący indeks)
						-[ZROBIONE]wprowadzenie postem wiersza na nieistniejący indeks
						-[ZROBIONE]komunikat błędu
						-[ZROBIONE]kod 200 z przeglądarki
				-[ZROBIONE]save_as_new
					-[ZROBIONE]sukces dodania nowego wiersza
						-[ZROBIONE]wprowadzenie nowego wiersza do pliku
						-[ZROBIONE]kod 200
					-[ZROBIONE]porażka
						-[ZROBIONE]zablokowany plik 
						-[ZROBIONE]odbiór wyjątku
						-[ZROBIONE]kod 200
			-[ZROBIONE]remove row
				-[ZROBIONE]success
					-[ZROBIONE]udane usunięcie
					-[ZROBIONE]kod 200
				-[ZROBIONE]porażka
					-[ZROBIONE]zablokowany plik 
					-[ZROBIONE]komunikat błędu
					-[ZROBIONE]potwierdzenie że linia dalej istnieje
					-[ZROBIONE]kod 200 
			-[ZROBIONE]do backup
				-[ZROBIONE]sukces	
					-[ZROBIONE]utworzenie nowego pliku
					-[ZROBIONE]pliki backup i orginał są takie same
					-[ZROBIONE]kod 200
			-[ZROBIONE]list of backups
				-[ZROBIONE]success
					-[ZROBIONE]lista backupów taka sama jak pliki .bak w folderze
					-[ZROBIONE]kod 200
			-[ZROBIONE]return from backup
				-[ZROBIONE]success
					-[ZROBIONE]skasować backupy
					-[ZROBIONE]zrobić backup
					-[ZROBIONE]zrobić zmianę w pliku csv
					-[ZROBIONE]przywrócić z backup
					-[ZROBIONE]potwierdzić że wprowadzonej zmiany nie ma po przywróceniu
					-[ZROBIONE]kod 200
				-[ZROBIONE]porażka
					-[ZROBIONE]skasować backupy
					-[ZROBIONE]zrobić backup
					-[ZROBIONE]zmiany w pliku csv
					-[ZROBIONE]zablokować plik csv do zapisu
					-[ZROBIONE]próba przywrócenia z bakapu
					-[ZROBIONE]wyłapać wyjątek
					-[ZROBIONE]kod 200

-[ZROBIONE]rozwiązać problem konieczności używania pełnych ścieżek do plików
	-zamiast tego powinny być ścieżki względne, czyli do samego katalogu aplikacji
	-[ZROBIONE]__init__.py 
		-[ZROBIONE]zacząć od wywalenia podwójnych slashy
			-rozwiązaniem jest biblioteka pathlib
	-[ZROBIONE]config.py 
		-[ZROBIONE]wywalić slashe
		-[ZROBIONE]dodać tylko ścieżki względne
	-[ZROBIONE]flatfile_operations
		-[ZROBIONE]Podmiana w CSV_PATH
		-[ZROBIONE]list_of_backups
			-[ZROBIONE]Wczytywanie ścieżek po nowemu
			-[ZROBIONE]na formularzu pokazywanie tylko nazw plików
			-[ZROBIONE]update testu
		-[ZROBIONE]show_backup
		-[ZROBIONE]Conftest i reszta błędów ścieżek
-[ZROBIONE]wydzielić funkcjonalności backupów do oddzielnego modułu
	-[ZROBIONE]zrobić to jako oddzielny blueprint
		-kurde radykalna zmiana bo połowę kodu przeniosłem do innego pliku
		 a tu jeb, wszystkie testy od razu przechodzą.
		-to też pokazuje jak bardzo przydatne było pisanie testów jednostkowych.
		 Normalnie musiałbym wszystkie operacje backupowe przeklikać na co poszłoby
		 spokojnie 15 minut.
	-[ZROBIONE]testy backupów wydzielić też do osobnego pliku
-[ZROBIONE]Postawić sobie na raspberry pi raspbiana lite i zrobić folder na docelowy plik csv
	-adres: 192.168.1.26, user: pi, hasło: uniwersalne1
	-[ZROBIONE]zrobić katalog na plik /home/pi/flatfile_ed
	-[ZROBIONE]zrobić plik scp_test.csv
-[ZROBIONE]pobieranie pliku przez scp z linuxa i upload przez scp
	-tu od razu trzeba równlegle robić testy
	-[ZROBIONE]poczytać czym mogę przesyłać sobie dane do linuxa po scp
		-biblioteki scp i paramiko
	-[ZROBIONE]poczytać jak sobie scp zrobić lokalnie na potrzeby testów automatycznych
		-biblioteka mock-ssh-server
	-[ZROBIONE]instalacja bibliotek scp, paramiko, mock-ssh-server na venv
	-[ZROBIONE]zestawianie połączenia
		-[ZROBIONE]konsola pythona
			-[ZROBIONE]Działający przykład w jupyter notebooku
		-[ZROBIONE]moduł komunikacji - scp_interface
			-[ZROBIONE]utworzyć nowy moduł jako blueprint
			-[ZROBIONE]opearacja test_connection
				-[ZROBIONE]routing	
				-[ZROBIONE]widok z komunikatami
				-[ZROBIONE]przeniesienie parametrów połączenia do konfigu żywego
	-[ZROBIONE]pobranie pliku 
		-[ZROBIONE]pobranie pliku i zastąpienie obecnego
		-[ZROBIONE]komunikaty sukcesu i porażki
		-[ZROBIONE]po pobraniu bedą te same operacje co na lokalnym pliku
	-[ZROBIONE]upload pliku
		-[ZROBIONE]komunikaty sukcesu i porażki

-[ZROBIONE]konfiguracja pliku csv (labele kolumn, dozwolone typy danych, regexy stringów)
	-[ZROBIONE]do poprawnego odczytu i zapisu uzyć dialektów biblioteki csv
		-csv.register_dialect('mydia', delimiter=',', quoting=csv.QUOTE_ALL, doublequote=True)
		-[ZROBIONE]dialekt csv będzie przekazywany parametrem do funkcji	
			-tu w ogóle można by zrobić z tego obiekt :)
			-[ZROBIONE]csv_interface
			-[ZROBIONE]config
			-[ZROBIONE]flatfile_operations
			-[ZROBIONE]backup_operations
			-[ZROBIONE]naprostować testy
	-[ZROBIONE]dodać testy jednostkowe do dialektu
		-[ZROBIONE]odczytywany plik jest plikiem csv zgodnym z zadeklarowanym dialektem
			-chyba atrybut dialektu 'strict' od razu rozwiąże mój problem
				-jednak nie - csv nie zwraca żadnego błędu
			-[ZROBIONE]sprawdzić pomysł sprawdzania ilości wykrytych kolumn
				-działa :)
				-co prawda test nie ma większego sensu ale udowodniłem że trochę ogarniam
			-[ZROBIONE]dodać walidację w funkcji get_csv	
				-[ZROBIONE]tam musi być walidator który sprawdza czy podany plik faktycznie ma zadeklarowaną
				 liczbę kolumn. W przypadku wykrytego błędu musi zwracać komunikat
					-albo zgłaszać wyjątek który będzie eskalowany wyżej.
		-odczytywany plik ma inny dialekt niż zadeklarowany
		-przy okazji wywalić ze test_csv_interface wszystkie względne ścieżki
	-[ZROBIONE]konfiguracja kolumn w konfigu
		-[ZROBIONE]dozowlona długość
		-[ZROBIONE]renderowanie tabelek i formularzy do edycji w oparciu o konfig
			-[ZROBIONEflatfile_operations
			-[ZROBIONE]backup_operations
		-[ZROBIONE]testy	
			-[ZROBIONE]zgodność odczytywanego pliku z formatem
				-[ZROBIONE]ilość kolumn

-logowanie zadrzeń do pliku loga
	-wywalanie aplikacji gdy wielkość pliku loga przekroczy limit bezpieczeństwa
		-w konfigu do ustalenia
		-gdy konfig jest niedostępny to 1 GB


-poprawić layout aplikacji
-uzupełnić dokumentację
	-wybrać licencję projektu na githubie na MIT
	-zrobić w miarę proste readme.md żeby to miało ręce i nogi

-zmodyfikować formularz append_row by dodawał dowolnie wybraną przez użytkownika ilość kolumn
	-dynamiczne dodawanie kolejnego wiersza na formularzu
		-tutaj trzeba użyć najprostszego js-a 
----testy do funkcjonalności wyżej

--testy aplikacji (w tym automatyczne)
						
-porozdzielać funkcjonalności na modele, kontrolery i widoki


-dodać możliwość łatwego deploymentu na inne maszyny
	-przećwiczyć temat na raspberry pi

-scp_interface - zmiana struktury kodu na bardziej obiektowy
-scp_interface - dopisać unit testy
-scp_interface - formularz do konfigu połączenia
-limitowanie dostępu do aplikacji (login i pass)
	-znaleźć dobry przykład (chyba jest nawet nas tronie flaska)
		-https://flask.palletsprojects.com/en/1.1.x/tutorial/views/
	-oddzielny moduł jako blue print
	-testy
-zewnętrzny konfig ftp 
	-odczyt z konfigu ustawień ftp
	-zapis ustawień przez formularz
	-test połączenia 
	-test transferu
-lockowanie edytowanego pliku za pomocą biblioteki filelock